Option Explicit

'==================================================================================================
' 全局变量用于统计
'==================================================================================================
Private g_TotalXlsFiles As Long
Private g_TotalACTFolders As Long

'==================================================================================================
' 主程序：遍历所有符合条件的文件夹和文件
' 增加了文件和文件夹统计功能，改进了内存管理
'==================================================================================================
Sub Main_ProcessAllFiles()

    ' --- 配置部分 ---
    Const ROOT_FOLDER_NAME As String = "DirectSale Reconcile Inputs"
    Const FOLDER_KEYWORD As String = "ACT"
    Const FILE_KEYWORD As String = "ACT"
    ' --- 配置结束 ---

    Dim fso As Object
    Dim rootFolder As Object
    Dim subFolder As Object
    Dim fileItem As Object
    Dim basePath As String
    Dim wsSummary As Worksheet
    Dim wsTemp As Worksheet

    ' 初始化统计变量
    g_TotalXlsFiles = 0
    g_TotalACTFolders = 0

    Set fso = CreateObject("Scripting.FileSystemObject")
    basePath = ThisWorkbook.Path & "\" & ROOT_FOLDER_NAME

    If Not fso.FolderExists(basePath) Then
        MsgBox "错误：找不到数据源文件夹 '" & basePath & "'", vbCritical, "文件夹未找到"
        Exit Sub
    End If

    ' 优化性能设置
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    On Error GoTo ErrorHandler

    ' 准备工作表
    SetupSheets wsSummary, wsTemp

    Set rootFolder = fso.GetFolder(basePath)

    ' 遍历所有子文件夹
    For Each subFolder In rootFolder.SubFolders
        If InStr(1, subFolder.Name, FOLDER_KEYWORD, vbTextCompare) > 0 Then
            g_TotalACTFolders = g_TotalACTFolders + 1
            
            ' 遍历文件夹中的所有文件
            For Each fileItem In subFolder.Files
                If InStr(1, fileItem.Name, FILE_KEYWORD, vbTextCompare) > 0 And _
                   LCase(fso.GetExtensionName(fileItem.Name)) = "xls" Then
                    g_TotalXlsFiles = g_TotalXlsFiles + 1
                    
                    ' 处理单个文件（使用改进的内存管理）
                    ProcessSingleFileOptimized fileItem.Path, wsSummary, wsTemp
                    
                    ' 强制垃圾回收以释放内存
                    DoEvents
                End If
            Next fileItem
        End If
    Next subFolder

    ' 在A1单元格写入统计信息
    With ThisWorkbook.ActiveSheet
        .Cells(1, 1).Value = "统计：处理了 " & g_TotalXlsFiles & " 个XLS文件，来自 " & g_TotalACTFolders & " 个ACT文件夹"
        .Cells(1, 1).Font.Bold = True
        .Cells(1, 1).Interior.Color = RGB(255, 255, 0) ' 黄色背景
    End With

    MsgBox "所有数据处理完成！" & vbCrLf & _
           "处理了 " & g_TotalXlsFiles & " 个XLS文件" & vbCrLf & _
           "来自 " & g_TotalACTFolders & " 个ACT文件夹" & vbCrLf & _
           "请检查'Summary Sheet'。", vbInformation, "处理完成"

CleanUp:
    ' 恢复Excel设置
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    Application.EnableEvents = True
    Application.Calculation = xlCalculationAutomatic
    
    ' 清理对象
    Set fso = Nothing
    Set rootFolder = Nothing
    Set subFolder = Nothing
    Set fileItem = Nothing
    Exit Sub

ErrorHandler:
    MsgBox "主程序发生错误：" & Err.Description, vbCritical, "错误"
    Resume CleanUp

End Sub

'==================================================================================================
' 辅助程序1：准备工作表
'==================================================================================================
Sub SetupSheets(ByRef wsSummary As Worksheet, ByRef wsTemp As Worksheet)
    On Error Resume Next
    
    ' 设置临时工作表
    Set wsTemp = ThisWorkbook.Sheets("Intermediate Sheet")
    If wsTemp Is Nothing Then
        Set wsTemp = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
        wsTemp.Name = "Intermediate Sheet"
    End If
    wsTemp.Cells.Clear

    ' 设置汇总工作表
    Set wsSummary = ThisWorkbook.Sheets("Summary Sheet")
    If wsSummary Is Nothing Then
        Set wsSummary = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
        wsSummary.Name = "Summary Sheet"
    End If
    wsSummary.Cells.Clear
    On Error GoTo 0

    ' 创建标题行
    With wsSummary
        .Cells(1, 1).Value = "Submission Date"
        .Cells(1, 2).Value = "Account #"
        .Cells(1, 3).Value = "Expire Date"
        .Cells(1, 4).Value = "Amount"
        ' 格式化标题行
        .Range("A1:D1").Font.Bold = True
        .Range("A1:D1").Interior.Color = RGB(200, 200, 200)
    End With
End Sub

'==================================================================================================
' 优化版本：使用ADO连接处理Excel文件，避免完全打开工作簿
' 解决Protected View和内存问题
'==================================================================================================
Sub ProcessSingleFileOptimized(ByVal fullPath As String, ByVal wsSummary As Worksheet, ByVal wsTemp As Worksheet)
    
    ' 首先尝试使用ADO方式（不打开文件）
    If ProcessFileWithADO(fullPath, wsSummary, wsTemp) Then
        Exit Sub ' ADO成功则退出
    End If
    
    ' 如果ADO失败，尝试传统方式但增加错误处理
    ProcessSingleFileTraditional fullPath, wsSummary, wsTemp
    
End Sub

'==================================================================================================
' 使用ADO连接读取Excel文件（不打开工作簿，解决Protected View问题）
'==================================================================================================
Function ProcessFileWithADO(ByVal fullPath As String, ByVal wsSummary As Worksheet, ByVal wsTemp As Worksheet) As Boolean
    
    Dim conn As Object
    Dim rs As Object
    Dim sql As String
    Dim connectionString As String
    Dim sheetName As String
    
    On Error GoTo ADOError
    
    ' 创建ADO连接
    Set conn = CreateObject("ADODB.Connection")
    Set rs = CreateObject("ADODB.Recordset")
    
    ' 构建连接字符串
    connectionString = "Provider=Microsoft.ACE.OLEDB.12.0;" & _
                      "Data Source=" & fullPath & ";" & _
                      "Extended Properties=""Excel 8.0;HDR=Yes;IMEX=1;"";"
    
    conn.Open connectionString
    
    ' 获取第一个工作表名称
    Set rs = conn.OpenSchema(20) ' adSchemaTables = 20
    If Not rs.EOF Then
        sheetName = rs.Fields("TABLE_NAME").Value
        sheetName = Replace(sheetName, "$", "") ' 移除$符号
    Else
        GoTo ADOError
    End If
    rs.Close
    
    ' 定义要查找的列
    Dim searchKeys As Variant
    searchKeys = Array( _
        Array("Submission Date", 1), _
        Array("Account #", 2), _
        Array("Expire Date", 3), _
        Array("Amount", 4) _
    )
    
    Dim i As Integer
    Dim nextSummaryRow As Long
    Dim colName As String
    
    ' 处理每个需要的列
    For i = LBound(searchKeys) To UBound(searchKeys)
        colName = searchKeys(i)(0)
        
        ' 构建SQL查询
        sql = "SELECT [" & colName & "] FROM [" & sheetName & "$] WHERE [" & colName & "] IS NOT NULL"
        
        On Error Resume Next
        Set rs = CreateObject("ADODB.Recordset")
        rs.Open sql, conn, 1, 1 ' adOpenKeyset, adLockReadOnly
        
        If Err.Number = 0 And Not rs.EOF Then
            ' 找到下一个空行
            nextSummaryRow = wsSummary.Cells(wsSummary.Rows.Count, searchKeys(i)(1)).End(xlUp).Row + 1
            
            ' 复制数据
            Dim rowCounter As Long
            rowCounter = nextSummaryRow
            
            Do While Not rs.EOF
                Dim cellValue As String
                cellValue = Trim(CStr(rs.Fields(0).Value))
                
                ' 过滤无效数据
                If cellValue <> "" And cellValue <> colName And _
                   Not (colName = "Submission Date" And InStr(1, cellValue, "Submission Count", vbTextCompare) > 0) Then
                    wsSummary.Cells(rowCounter, searchKeys(i)(1)).Value = rs.Fields(0).Value
                    rowCounter = rowCounter + 1
                End If
                
                rs.MoveNext
            Loop
            
            rs.Close
        End If
        On Error GoTo ADOError
        
    Next i
    
    conn.Close
    Set rs = Nothing
    Set conn = Nothing
    
    ProcessFileWithADO = True
    Exit Function
    
ADOError:
    On Error Resume Next
    If Not rs Is Nothing Then rs.Close
    If Not conn Is Nothing Then conn.Close
    Set rs = Nothing
    Set conn = Nothing
    ProcessFileWithADO = False

End Function

'==================================================================================================
' 传统方式处理文件（改进版，增加Protected View处理）
'==================================================================================================
Sub ProcessSingleFileTraditional(ByVal fullPath As String, ByVal wsSummary As Worksheet, ByVal wsTemp As Worksheet)

    Dim wbSource As Workbook
    Dim wsSource As Worksheet
    Dim findRange As Range
    Dim lastRowSource As Long
    Dim lastRowTemp As Long
    Dim nextSummaryRow As Long
    Dim colCounter As Integer
    Dim searchKey As Variant
    Dim targetColumnSource As Long
    Dim tempColOffset As Long
    Dim i As Long
    Dim copyCurrentColumn As Boolean

    Dim searchKeys As Variant
    searchKeys = Array( _
        Array("Submission Date", 1, True), _
        Array("Account #", 2, False), _
        Array("Expire Date", 3, True), _
        Array("Amount", 4, False) _
    )

    On Error GoTo ErrorHandler

    ' 尝试以只读和非Protected View方式打开
    Set wbSource = Application.Workbooks.Open(Filename:=fullPath, _
                                             ReadOnly:=True, _
                                             UpdateLinks:=False, _
                                             AddToMru:=False, _
                                             IgnoreReadOnlyRecommended:=True)

    ' 如果打开的是Protected View，尝试启用编辑
    If wbSource.ProtectedViewWindow Is Nothing Then
        Set wsSource = wbSource.Sheets(1)
    Else
        ' 处理Protected View
        wbSource.ProtectedViewWindow.Edit
        DoEvents ' 等待编辑模式启用
        Set wsSource = wbSource.Sheets(1)
    End If

    ' 处理每个关键字
    For colCounter = LBound(searchKeys) To UBound(searchKeys)
        searchKey = searchKeys(colCounter)(0)
        tempColOffset = searchKeys(colCounter)(1)
        copyCurrentColumn = searchKeys(colCounter)(2)

        wsTemp.Cells.ClearContents

        Set findRange = wsSource.Cells.Find(What:=searchKey, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)

        If Not findRange Is Nothing Then
            If copyCurrentColumn Then
                targetColumnSource = findRange.Column
            Else
                targetColumnSource = findRange.Column - 1
                If targetColumnSource < 1 Then GoTo NextKey
            End If

            lastRowSource = wsSource.Cells(wsSource.Rows.Count, targetColumnSource).End(xlUp).Row
            If lastRowSource <= findRange.Row Then GoTo NextKey

            ' 复制数据到临时工作表
            wsSource.Range(wsSource.Cells(findRange.Row + 1, targetColumnSource), _
                          wsSource.Cells(lastRowSource, targetColumnSource)).Copy
            wsTemp.Cells(2, 1).PasteSpecial xlPasteValuesAndNumberFormats
            Application.CutCopyMode = False

            ' 数据清理
            lastRowTemp = wsTemp.Cells(wsTemp.Rows.Count, 1).End(xlUp).Row
            If lastRowTemp >= 2 Then
                For i = lastRowTemp To 2 Step -1
                    Dim cellValue As String
                    cellValue = Trim(wsTemp.Cells(i, 1).Value)
                    If cellValue = "" Or cellValue = CStr(searchKey) Or _
                       (CStr(searchKey) = "Submission Date" And InStr(1, cellValue, "Submission Count", vbTextCompare) > 0) Then
                        wsTemp.Rows(i).Delete
                    End If
                Next i
            End If

            ' 复制清理后的数据到汇总表
            lastRowTemp = wsTemp.Cells(wsTemp.Rows.Count, 1).End(xlUp).Row
            If lastRowTemp >= 2 Then
                nextSummaryRow = wsSummary.Cells(wsSummary.Rows.Count, tempColOffset).End(xlUp).Row + 1
                wsTemp.Range("A2:A" & lastRowTemp).Copy
                wsSummary.Cells(nextSummaryRow, tempColOffset).PasteSpecial xlPasteValuesAndNumberFormats
                Application.CutCopyMode = False
            End If
        End If

NextKey:
    Next colCounter

CleanUp:
    If Not wbSource Is Nothing Then
        wbSource.Close SaveChanges:=False
        Set wbSource = Nothing
        Set wsSource = Nothing
    End If
    
    ' 强制垃圾回收
    DoEvents
    Exit Sub

ErrorHandler:
    MsgBox "处理文件时发生错误 '" & fullPath & "':" & vbCrLf & Err.Description, vbExclamation, "文件处理错误"
    Resume CleanUp

End Sub

'==================================================================================================
' 内存清理辅助程序
'==================================================================================================
Sub ForceMemoryCleanup()
    DoEvents
    Application.CutCopyMode = False
    ' 可以添加其他内存清理操作
End Sub