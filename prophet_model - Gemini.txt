def predict(self, start_date, end_date, output_agg_level):
    """预测方法（修复版：在最后强制加上限）"""
    freq = {'daily': 'D', 'weekly': 'W-MON', 'monthly': 'MS'}[output_agg_level]
    dates = pd.date_range(start=start_date, end=end_date, freq=freq)

    if not self.model:
        logging.warning(f"{self.name} 无模型")
        return pd.DataFrame({'Dates': dates, 'Predictions': np.zeros(len(dates))})

    date_col = next(
        col for col in ['Correct Event Time', 'Date', 'WeekStart', 'MonthStart'] 
        if col in self.data.columns
    )

    # 读取特殊事件（保持原有逻辑）
    try:
        special_events = pd.read_excel(
            os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Spreadsheets Source', 'Special Event.xlsx'),
            parse_dates=['Date'])
        special_events = special_events[
            (special_events['Date'] >= start_date) & (special_events['Date'] <= end_date)]
        special_events_agg = special_events.groupby('Date').agg({
            'Special Event': lambda x: ';'.join(str(i) for i in x if pd.notna(i)),
            'Special Event City': lambda x: ';'.join(str(i) for i in x if pd.notna(i)),
            'Event Type': lambda x: ';'.join(str(i) for i in x if pd.notna(i)),
            'Impact Scale': 'mean'
        }).reset_index()
    except FileNotFoundError:
        special_events_agg = pd.DataFrame({
            'Date': dates,
            'Special Event': [''] * len(dates),
            'Special Event City': [''] * len(dates),
            'Event Type': [''] * len(dates),
            'Impact Scale': [1.0] * len(dates)
        })

    # 准备未来数据（保持原有逻辑）
    future_df = pd.DataFrame({date_col: dates})
    future_df = future_df.merge(special_events_agg, left_on=date_col, right_on='Date', how='left')
    future_df.fillna({'Special Event': '', 'Special Event City': '', 'Event Type': '', 'Impact Scale': 1.0},
                     inplace=True)

    future_df = self.feature_engineer.preprocess_features(future_df, date_col, is_training=False)
    future_df[date_col] = pd.to_datetime(future_df[date_col])

    for col in self.feature_engineer.get_feature_cols():
        if col not in future_df.columns:
            future_df[col] = 0

    future_prophet = future_df.rename(columns={date_col: 'ds'})
    
    try:
        forecast = self.model.predict(future_prophet[['ds'] + self.feature_engineer.get_feature_cols()])
        raw_predictions = forecast['yhat'].clip(lower=0)
        adjusted_predictions = self._apply_intelligent_floor(raw_predictions, dates)
        final_predictions = adjusted_predictions.clip(lower=0)
    except Exception as e:
        logging.error(f"预测失败: {str(e)}")
        return pd.DataFrame({'Dates': dates, 'Predictions': np.zeros(len(dates))})

    # ========== 新增：最后一道防线，强制上限 ==========
    last_year_data = self.data.copy()
    last_year_data[date_col] = pd.to_datetime(last_year_data[date_col])
    
    hard_capped_predictions = []
    
    for i, pred_date in enumerate(dates):
        pred_value = final_predictions.iloc[i]
        target_month = pred_date.month
        target_year = pred_date.year
        
        # 找去年同月的平均值
        last_year_mask = (last_year_data[date_col].dt.month == target_month) & \
                         (last_year_data[date_col].dt.year == target_year - 1)
        
        if not last_year_mask.any():
            last_year_mask = (last_year_data[date_col].dt.month == target_month) & \
                             (last_year_data[date_col].dt.year == target_year - 2)
        
        if not last_year_mask.any():
            last_year_mask = (last_year_data[date_col].dt.month == target_month)
        
        if last_year_mask.any():
            last_year_avg = last_year_data[last_year_mask]['Actual Pax'].mean()
        else:
            last_year_avg = self.historical_pax_mean
        
        # 如果去年同期接近0，强制为0
        if last_year_avg <= 10:
            capped_value = 0.0
        # 淡季：上限=去年同期2倍
        elif target_month in [1, 2, 3, 10, 11, 12]:
            capped_value = min(pred_value, last_year_avg * 2.0)
        # 旺季：上限=历史最大值1.5倍
        else:
            capped_value = min(pred_value, self.max_historical_pax * 1.5)
        
        hard_capped_predictions.append(capped_value)
    
    # 用强制上限后的结果替换
    final_predictions = pd.Series(hard_capped_predictions).clip(lower=0)
    
    return pd.DataFrame({'Dates': dates, 'Predictions': final_predictions})
