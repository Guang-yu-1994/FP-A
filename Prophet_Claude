import pandas as pd
import numpy as np
import logging

# ============================================================================
# æ ¸å¿ƒä¿®å¤ï¼šæ™ºèƒ½å»å¹´åŒæœŸæŸ¥æ‰¾ï¼ˆåªç”¨å®é™…æ•°æ®ï¼Œä¸ç”¨é¢„æµ‹å€¼ï¼‰
# ============================================================================

def _get_last_year_value(self, pred_date, last_year_data, date_col):
    """
    ä¿®å¤ç­–ç•¥ï¼š
    1. ä¼˜å…ˆæŸ¥æ‰¾pred_date-1å¹´çš„å®é™…æ•°æ®
    2. å¦‚æœæ‰¾ä¸åˆ°ï¼Œå‘å‰æŸ¥æ‰¾æœ€è¿‘2å¹´çš„å®é™…æ•°æ®
    3. å¦‚æœè¿˜æ‰¾ä¸åˆ°ï¼Œä½¿ç”¨å†å²å­£èŠ‚æ€§å‡å€¼
    4. ç»ä¸è¿”å›0ï¼ˆé¿å…è§¦å‘å½’é›¶é€»è¾‘ï¼‰
    """
    # ç¡®ä¿last_year_dataåªåŒ…å«å®é™…å†å²æ•°æ®ï¼ˆä¸åŒ…å«é¢„æµ‹å€¼ï¼‰
    # å‡è®¾ä½ çš„å®é™…æ•°æ®æœ€æ™šåˆ°2025å¹´10æœˆ
    actual_data = last_year_data[last_year_data[date_col] <= pd.Timestamp('2025-10-31')]
    
    if len(actual_data) == 0:
        logging.warning(f"{self.name} æ— å®é™…å†å²æ•°æ®ï¼")
        return self._get_historical_baseline(pred_date)
    
    # ç­–ç•¥1ï¼šæŸ¥æ‰¾å»å¹´åŒæœŸï¼ˆpred_date - 1å¹´ï¼‰
    last_year = pred_date.year - 1
    if self.time_level == 'weekly':
        pred_week = pred_date.isocalendar().week
        mask = (actual_data[date_col].dt.year == last_year) & \
               (actual_data[date_col].dt.isocalendar().week == pred_week)
    elif self.time_level == 'monthly':
        pred_month = pred_date.month
        mask = (actual_data[date_col].dt.year == last_year) & \
               (actual_data[date_col].dt.month == pred_month)
    else:  # daily
        last_year_date = pred_date - pd.DateOffset(years=1)
        mask = (actual_data[date_col] >= last_year_date - pd.Timedelta(days=3)) & \
               (actual_data[date_col] <= last_year_date + pd.Timedelta(days=3))
    
    if mask.any():
        value = actual_data[mask]['Actual Pax'].mean()
        logging.debug(f"{self.name} {pred_date.date()} [å»å¹´åŒæœŸ]: æ‰¾åˆ° {last_year.year} å¹´æ•°æ®ï¼Œå€¼={value:.1f}")
        return value
    
    # ç­–ç•¥2ï¼šæ‰¾ä¸åˆ°å»å¹´ï¼ŒæŸ¥æ‰¾å‰2å¹´åŒæœŸï¼ˆpred_date - 2å¹´ï¼‰
    two_years_ago = pred_date.year - 2
    if self.time_level == 'weekly':
        mask = (actual_data[date_col].dt.year == two_years_ago) & \
               (actual_data[date_col].dt.isocalendar().week == pred_week)
    elif self.time_level == 'monthly':
        mask = (actual_data[date_col].dt.year == two_years_ago) & \
               (actual_data[date_col].dt.month == pred_month)
    else:
        two_years_ago_date = pred_date - pd.DateOffset(years=2)
        mask = (actual_data[date_col] >= two_years_ago_date - pd.Timedelta(days=3)) & \
               (actual_data[date_col] <= two_years_ago_date + pd.Timedelta(days=3))
    
    if mask.any():
        value = actual_data[mask]['Actual Pax'].mean()
        logging.debug(f"{self.name} {pred_date.date()} [å‰2å¹´åŒæœŸ]: æ‰¾åˆ° {two_years_ago.year} å¹´æ•°æ®ï¼Œå€¼={value:.1f}")
        return value
    
    # ç­–ç•¥3ï¼šæŸ¥æ‰¾è¯¥æ—¶æœŸï¼ˆå‘¨/æœˆï¼‰çš„æ‰€æœ‰å†å²æ•°æ®å‡å€¼
    if self.time_level == 'weekly':
        mask = actual_data[date_col].dt.isocalendar().week == pred_week
    elif self.time_level == 'monthly':
        mask = actual_data[date_col].dt.month == pred_month
    else:
        # dailyï¼šæŸ¥æ‰¾åŒä¸€å¤©åœ¨æ‰€æœ‰å¹´ä»½çš„æ•°æ®
        mask = (actual_data[date_col].dt.month == pred_date.month) & \
               (actual_data[date_col].dt.day == pred_date.day)
    
    if mask.any():
        value = actual_data[mask]['Actual Pax'].mean()
        logging.debug(f"{self.name} {pred_date.date()} [å†å²åŒæœŸå‡å€¼]: {value:.1f}")
        return value
    
    # ç­–ç•¥4ï¼šä½¿ç”¨å†å²å­£èŠ‚æ€§åŸºçº¿ï¼ˆæœ€åçš„fallbackï¼‰
    baseline = self._get_historical_baseline(pred_date)
    logging.debug(f"{self.name} {pred_date.date()} [å­£èŠ‚æ€§åŸºçº¿]: {baseline:.1f}")
    return baseline


def _get_historical_baseline(self, pred_date):
    """è·å–å†å²å­£èŠ‚æ€§åŸºçº¿ï¼ˆç¡®ä¿éé›¶ï¼‰"""
    if self.historical_seasonality is not None:
        if self.time_level == 'weekly':
            week_num = pred_date.isocalendar()[1]
            baseline = self.historical_seasonality.get(week_num, self.historical_pax_mean)
        else:
            month_num = pred_date.month
            baseline = self.historical_seasonality.get(month_num, self.historical_pax_mean)
    else:
        baseline = self.historical_pax_mean
    
    # ç¡®ä¿åŸºçº¿è‡³å°‘ä¸ºå†å²å‡å€¼çš„20%ï¼ˆé¿å…æç«¯å°å€¼ï¼‰
    return max(baseline, self.historical_pax_mean * 0.2)


# ============================================================================
# ä¿®å¤æ·¡å­£ä¸Šé™é€»è¾‘ï¼ˆåªåœ¨å‚è€ƒå€¼å¯é æ—¶å¯ç”¨ï¼‰
# ============================================================================

def _apply_low_season_cap(self, raw_pred, last_year_value, pred_date):
    """
    æ·¡å­£ä¸Šé™è§„åˆ™ï¼š
    - åªåœ¨last_year_valueè¶³å¤Ÿå¤§æ—¶æ‰å¯ç”¨ï¼ˆé¿å…last_year_value=0çš„æƒ…å†µï¼‰
    - ä¸Šé™è®¾ä¸ºå»å¹´åŒæœŸçš„2å€
    """
    adjusted_pred = raw_pred
    is_low_season = pred_date.month in [1, 2, 3, 10, 11, 12]
    
    # ğŸ”§ å…³é”®ä¿®å¤ï¼šåªåœ¨å‚è€ƒå€¼ > å†å²å‡å€¼çš„30% æ—¶æ‰å¯ç”¨ä¸Šé™
    min_threshold = self.historical_pax_mean * 0.3
    
    if is_low_season and last_year_value > min_threshold:
        cap = last_year_value * 2.0
        if raw_pred > cap:
            adjusted_pred = cap
            logging.debug(f"{self.name} {pred_date.date()} [æ·¡å­£å°é¡¶]: {raw_pred:.1f} -> {cap:.1f} (å‚è€ƒå€¼={last_year_value:.1f})")
        else:
            logging.debug(f"{self.name} {pred_date.date()} [æ·¡å­£å°é¡¶]: æœªè§¦å‘ (é¢„æµ‹={raw_pred:.1f}, ä¸Šé™={cap:.1f})")
    else:
        if is_low_season:
            logging.debug(f"{self.name} {pred_date.date()} [æ·¡å­£å°é¡¶]: è·³è¿‡ (å‚è€ƒå€¼={last_year_value:.1f} < é˜ˆå€¼={min_threshold:.1f})")
        else:
            logging.debug(f"{self.name} {pred_date.date()} [éæ·¡å­£]: è·³è¿‡å°é¡¶")
    
    return adjusted_pred


# ============================================================================
# ä¿®å¤ä¸‹é™ä¿æŠ¤é€»è¾‘ï¼ˆç¡®ä¿ä¸ä¼šå› ä¸ºlast_year_value=0è€Œå¤±æ•ˆï¼‰
# ============================================================================

def _apply_low_prediction_floor(self, adjusted_pred, last_year_value, pred_date):
    """
    ä¸‹é™ä¿æŠ¤è§„åˆ™ï¼š
    - å¦‚æœé¢„æµ‹å€¼è¿‡ä½ï¼Œæå‡è‡³åˆç†åŸºçº¿
    - åŸºçº¿è®¡ç®—åŒæ—¶è€ƒè™‘å»å¹´åŒæœŸå’Œå†å²å‡å€¼
    """
    # ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æ›´ç¨³å¥çš„é˜ˆå€¼è®¡ç®—
    if last_year_value > self.historical_pax_mean * 0.3:
        # å»å¹´åŒæœŸå€¼å¯é ï¼Œä½¿ç”¨å®ƒä½œä¸ºå‚è€ƒ
        threshold = last_year_value * 0.2
    else:
        # å»å¹´åŒæœŸå€¼ä¸å¯é ï¼ˆå¤ªå°æˆ–ä¸º0ï¼‰ï¼Œä½¿ç”¨å†å²å‡å€¼
        threshold = self.historical_pax_mean * 0.1
    
    if adjusted_pred < threshold:
        # è®¡ç®—åˆç†åŸºçº¿
        smoothed_growth = 0.6 * self.ytd_growth_rate + 0.4 * (self.recent_trend_ratio - 1)
        smoothed_growth = max(smoothed_growth, -0.4)  # é¿å…è¿‡åº¦è´Ÿå¢é•¿
        
        # è·å–å­£èŠ‚æ€§å› å­
        if self.historical_seasonality is not None:
            if self.time_level == 'weekly':
                week_num = pred_date.isocalendar()[1]
                seasonal_factor = self.historical_seasonality.get(week_num, 1.0) / (self.historical_pax_mean + 1e-9)
            else:
                month_num = pred_date.month
                seasonal_factor = self.historical_seasonality.get(month_num, 1.0) / (self.historical_pax_mean + 1e-9)
        else:
            seasonal_factor = 1.0
        
        # ğŸ”§ ä¿®å¤ï¼šåŸºçº¿è®¡ç®—é€»è¾‘
        if last_year_value > self.historical_pax_mean * 0.3:
            # å‚è€ƒå€¼å¯é 
            baseline = last_year_value * (1 + smoothed_growth) * seasonal_factor
            upper_bound = last_year_value * 1.5
        else:
            # å‚è€ƒå€¼ä¸å¯é ï¼Œä½¿ç”¨å†å²å‡å€¼
            baseline = self.historical_pax_mean * seasonal_factor * (1 + max(smoothed_growth, -0.2))
            upper_bound = self.historical_pax_mean * 1.5
        
        adjusted_pred = min(max(adjusted_pred, baseline), upper_bound)
        logging.debug(f"{self.name} {pred_date.date()} [ä¸‹é™ä¿æŠ¤]: æå‡è‡³ {adjusted_pred:.1f} (åŸºçº¿={baseline:.1f})")
    else:
        logging.debug(f"{self.name} {pred_date.date()} [ä¸‹é™ä¿æŠ¤]: æœªè§¦å‘ (é¢„æµ‹={adjusted_pred:.1f} > é˜ˆå€¼={threshold:.1f})")
    
    return adjusted_pred


# ============================================================================
# ä¸»è°ƒæ•´å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼Œåªæ˜¯è°ƒç”¨ä¿®å¤åçš„å­å‡½æ•°ï¼‰
# ============================================================================

def _apply_intelligent_floor(self, predictions, dates):
    """ä¸»è°ƒæ•´å‡½æ•°ï¼šå…ˆæ·¡å­£ä¸Šé™ï¼Œå†è¿‡ä½ä¸‹é™"""
    last_year_data = self.data.copy()
    date_col = next(col for col in ['Correct Event Time', 'Date', 'WeekStart', 'MonthStart'] 
                   if col in last_year_data.columns)
    last_year_data[date_col] = pd.to_datetime(last_year_data[date_col])

    adjusted_predictions = []
    for i, pred_date in enumerate(dates):
        raw_pred = predictions.iloc[i]
        logging.debug(f"\n{self.name} {pred_date.date()} [é¢„æµ‹å¼€å§‹]: åŸå§‹={raw_pred:.1f}")

        # ğŸ”§ ä½¿ç”¨ä¿®å¤åçš„æŸ¥æ‰¾é€»è¾‘
        last_year_value = self._get_last_year_value(pred_date, last_year_data, date_col)

        # å…ˆæ·¡å­£ä¸Šé™
        adjusted_pred = self._apply_low_season_cap(raw_pred, last_year_value, pred_date)

        # å†è¿‡ä½ä¸‹é™
        adjusted_pred = self._apply_low_prediction_floor(adjusted_pred, last_year_value, pred_date)

        adjusted_predictions.append(adjusted_pred)

    logging.debug(f"\n{self.name} [è°ƒæ•´ç»“æœ]: åŸå§‹å‡å€¼={predictions.mean():.1f}, è°ƒæ•´åå‡å€¼={pd.Series(adjusted_predictions).mean():.1f}")
    return pd.Series(adjusted_predictions)
