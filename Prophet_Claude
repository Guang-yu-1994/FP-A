import pandas as pd
import numpy as np
import logging

# ============================================================================
# 核心修复：智能去年同期查找（只用实际数据，不用预测值）
# ============================================================================

def _get_last_year_value(self, pred_date, last_year_data, date_col):
    """
    修复策略：
    1. 优先查找pred_date-1年的实际数据
    2. 如果找不到，向前查找最近2年的实际数据
    3. 如果还找不到，使用历史季节性均值
    4. 绝不返回0（避免触发归零逻辑）
    """
    # 确保last_year_data只包含实际历史数据（不包含预测值）
    # 假设你的实际数据最晚到2025年10月
    actual_data = last_year_data[last_year_data[date_col] <= pd.Timestamp('2025-10-31')]
    
    if len(actual_data) == 0:
        logging.warning(f"{self.name} 无实际历史数据！")
        return self._get_historical_baseline(pred_date)
    
    # 策略1：查找去年同期（pred_date - 1年）
    last_year = pred_date.year - 1
    if self.time_level == 'weekly':
        pred_week = pred_date.isocalendar().week
        mask = (actual_data[date_col].dt.year == last_year) & \
               (actual_data[date_col].dt.isocalendar().week == pred_week)
    elif self.time_level == 'monthly':
        pred_month = pred_date.month
        mask = (actual_data[date_col].dt.year == last_year) & \
               (actual_data[date_col].dt.month == pred_month)
    else:  # daily
        last_year_date = pred_date - pd.DateOffset(years=1)
        mask = (actual_data[date_col] >= last_year_date - pd.Timedelta(days=3)) & \
               (actual_data[date_col] <= last_year_date + pd.Timedelta(days=3))
    
    if mask.any():
        value = actual_data[mask]['Actual Pax'].mean()
        logging.debug(f"{self.name} {pred_date.date()} [去年同期]: 找到 {last_year.year} 年数据，值={value:.1f}")
        return value
    
    # 策略2：找不到去年，查找前2年同期（pred_date - 2年）
    two_years_ago = pred_date.year - 2
    if self.time_level == 'weekly':
        mask = (actual_data[date_col].dt.year == two_years_ago) & \
               (actual_data[date_col].dt.isocalendar().week == pred_week)
    elif self.time_level == 'monthly':
        mask = (actual_data[date_col].dt.year == two_years_ago) & \
               (actual_data[date_col].dt.month == pred_month)
    else:
        two_years_ago_date = pred_date - pd.DateOffset(years=2)
        mask = (actual_data[date_col] >= two_years_ago_date - pd.Timedelta(days=3)) & \
               (actual_data[date_col] <= two_years_ago_date + pd.Timedelta(days=3))
    
    if mask.any():
        value = actual_data[mask]['Actual Pax'].mean()
        logging.debug(f"{self.name} {pred_date.date()} [前2年同期]: 找到 {two_years_ago.year} 年数据，值={value:.1f}")
        return value
    
    # 策略3：查找该时期（周/月）的所有历史数据均值
    if self.time_level == 'weekly':
        mask = actual_data[date_col].dt.isocalendar().week == pred_week
    elif self.time_level == 'monthly':
        mask = actual_data[date_col].dt.month == pred_month
    else:
        # daily：查找同一天在所有年份的数据
        mask = (actual_data[date_col].dt.month == pred_date.month) & \
               (actual_data[date_col].dt.day == pred_date.day)
    
    if mask.any():
        value = actual_data[mask]['Actual Pax'].mean()
        logging.debug(f"{self.name} {pred_date.date()} [历史同期均值]: {value:.1f}")
        return value
    
    # 策略4：使用历史季节性基线（最后的fallback）
    baseline = self._get_historical_baseline(pred_date)
    logging.debug(f"{self.name} {pred_date.date()} [季节性基线]: {baseline:.1f}")
    return baseline


def _get_historical_baseline(self, pred_date):
    """获取历史季节性基线（确保非零）"""
    if self.historical_seasonality is not None:
        if self.time_level == 'weekly':
            week_num = pred_date.isocalendar()[1]
            baseline = self.historical_seasonality.get(week_num, self.historical_pax_mean)
        else:
            month_num = pred_date.month
            baseline = self.historical_seasonality.get(month_num, self.historical_pax_mean)
    else:
        baseline = self.historical_pax_mean
    
    # 确保基线至少为历史均值的20%（避免极端小值）
    return max(baseline, self.historical_pax_mean * 0.2)


# ============================================================================
# 修复淡季上限逻辑（只在参考值可靠时启用）
# ============================================================================

def _apply_low_season_cap(self, raw_pred, last_year_value, pred_date):
    """
    淡季上限规则：
    - 只在last_year_value足够大时才启用（避免last_year_value=0的情况）
    - 上限设为去年同期的2倍
    """
    adjusted_pred = raw_pred
    is_low_season = pred_date.month in [1, 2, 3, 10, 11, 12]
    
    # 🔧 关键修复：只在参考值 > 历史均值的30% 时才启用上限
    min_threshold = self.historical_pax_mean * 0.3
    
    if is_low_season and last_year_value > min_threshold:
        cap = last_year_value * 2.0
        if raw_pred > cap:
            adjusted_pred = cap
            logging.debug(f"{self.name} {pred_date.date()} [淡季封顶]: {raw_pred:.1f} -> {cap:.1f} (参考值={last_year_value:.1f})")
        else:
            logging.debug(f"{self.name} {pred_date.date()} [淡季封顶]: 未触发 (预测={raw_pred:.1f}, 上限={cap:.1f})")
    else:
        if is_low_season:
            logging.debug(f"{self.name} {pred_date.date()} [淡季封顶]: 跳过 (参考值={last_year_value:.1f} < 阈值={min_threshold:.1f})")
        else:
            logging.debug(f"{self.name} {pred_date.date()} [非淡季]: 跳过封顶")
    
    return adjusted_pred


# ============================================================================
# 修复下限保护逻辑（确保不会因为last_year_value=0而失效）
# ============================================================================

def _apply_low_prediction_floor(self, adjusted_pred, last_year_value, pred_date):
    """
    下限保护规则：
    - 如果预测值过低，提升至合理基线
    - 基线计算同时考虑去年同期和历史均值
    """
    # 🔧 修复：使用更稳健的阈值计算
    if last_year_value > self.historical_pax_mean * 0.3:
        # 去年同期值可靠，使用它作为参考
        threshold = last_year_value * 0.2
    else:
        # 去年同期值不可靠（太小或为0），使用历史均值
        threshold = self.historical_pax_mean * 0.1
    
    if adjusted_pred < threshold:
        # 计算合理基线
        smoothed_growth = 0.6 * self.ytd_growth_rate + 0.4 * (self.recent_trend_ratio - 1)
        smoothed_growth = max(smoothed_growth, -0.4)  # 避免过度负增长
        
        # 获取季节性因子
        if self.historical_seasonality is not None:
            if self.time_level == 'weekly':
                week_num = pred_date.isocalendar()[1]
                seasonal_factor = self.historical_seasonality.get(week_num, 1.0) / (self.historical_pax_mean + 1e-9)
            else:
                month_num = pred_date.month
                seasonal_factor = self.historical_seasonality.get(month_num, 1.0) / (self.historical_pax_mean + 1e-9)
        else:
            seasonal_factor = 1.0
        
        # 🔧 修复：基线计算逻辑
        if last_year_value > self.historical_pax_mean * 0.3:
            # 参考值可靠
            baseline = last_year_value * (1 + smoothed_growth) * seasonal_factor
            upper_bound = last_year_value * 1.5
        else:
            # 参考值不可靠，使用历史均值
            baseline = self.historical_pax_mean * seasonal_factor * (1 + max(smoothed_growth, -0.2))
            upper_bound = self.historical_pax_mean * 1.5
        
        adjusted_pred = min(max(adjusted_pred, baseline), upper_bound)
        logging.debug(f"{self.name} {pred_date.date()} [下限保护]: 提升至 {adjusted_pred:.1f} (基线={baseline:.1f})")
    else:
        logging.debug(f"{self.name} {pred_date.date()} [下限保护]: 未触发 (预测={adjusted_pred:.1f} > 阈值={threshold:.1f})")
    
    return adjusted_pred


# ============================================================================
# 主调整函数（保持不变，只是调用修复后的子函数）
# ============================================================================

def _apply_intelligent_floor(self, predictions, dates):
    """主调整函数：先淡季上限，再过低下限"""
    last_year_data = self.data.copy()
    date_col = next(col for col in ['Correct Event Time', 'Date', 'WeekStart', 'MonthStart'] 
                   if col in last_year_data.columns)
    last_year_data[date_col] = pd.to_datetime(last_year_data[date_col])

    adjusted_predictions = []
    for i, pred_date in enumerate(dates):
        raw_pred = predictions.iloc[i]
        logging.debug(f"\n{self.name} {pred_date.date()} [预测开始]: 原始={raw_pred:.1f}")

        # 🔧 使用修复后的查找逻辑
        last_year_value = self._get_last_year_value(pred_date, last_year_data, date_col)

        # 先淡季上限
        adjusted_pred = self._apply_low_season_cap(raw_pred, last_year_value, pred_date)

        # 再过低下限
        adjusted_pred = self._apply_low_prediction_floor(adjusted_pred, last_year_value, pred_date)

        adjusted_predictions.append(adjusted_pred)

    logging.debug(f"\n{self.name} [调整结果]: 原始均值={predictions.mean():.1f}, 调整后均值={pd.Series(adjusted_predictions).mean():.1f}")
    return pd.Series(adjusted_predictions)
